# OMCP项目系统设计与数据库设计

# —— TOM & JERRY 团队

## 一、团队项目预期开发时间安排

| 时间        | 团队目标与产出                                               |
| ----------- | ------------------------------------------------------------ |
| 6.14 - 6.15 | 初期，制作系统设计、数据库设计说明书 ，系统设计和数据库设计  |
| 6.16 - 6.20 | 分工，前端完成基础页面设计，后端完成 Java 代码               |
| 6.21 - 6.24 | 前端基本页面跳转完成 ，后端创建数据库，完成模块和数据库的连接 |
| 6.25 - 6.27 | 前端进行 UI 统一以及美化界面，后端测试并完善基础功能接口     |
| 6.28 - 6.30 | 前端连接后端接口，进行软件运行测试 ；后端进行完整性校验，根据不足之处更改后端代码，完善功能 |
| 7.1 - 7.5   | 收尾阶段，保证基本功能运行正常，页面效果对用户友好，检查 bug 和系统后期维护 |

## 二、预期开发计划分工安排

|   学号   |  姓名  |           工作内容           |
| :------: | :----: | :--------------------------: |
| 20177595 |  林金  |  项目需求规划、前端页面设计  |
| 20177598 | 李安娜 |         前端页面设计         |
| 20177603 |  高洁  | 统筹规划，后端设计，项目经理 |
| 20177615 | 刘超然 | 后端与前端交互设计、算法设计 |
| 20177625 |  黄波  |       数据库设计、测试       |
| 20177626 |  蒋晨  |         前端页面设计         |
| 20177629 | 刘丙亮 |    前端页面设计实现、测试    |
| 20177642 | 何昆佰 | 后端设计实现、算法设计、组长 |

## 三、项目系统及数据库设计

### 3. 1 体系结构设计 + 功能模块层次图

#### 3. 1. 1 体系结构设计

#### 3. 1. 2 功能模块

![](https://img2020.cnblogs.com/blog/1417334/202006/1417334-20200613213007110-1367149292.png)

### 3. 2 类图

### 3. 3 ER 分析 + 表结构设计

#### 3. 3. 1 ER 图

- 用户图

![](https://i.loli.net/2020/06/13/IwHXVEa97TSOA6Q.png)

- 管理员图

![](https://i.loli.net/2020/06/13/UjzNBlObPVoM35A.png)

#### 3. 3. 2 表结构设计

User表

| 字段名   | 数据类型 | 长度 | 主键 | 非空 | 描述    |
| -------- | -------- | ---- | ---- | ---- | ------- |
| username | varchar  | 8    | 是   | 是   | 用户名  |
| password | varchar  | 10   | 否   | 是   | 密码    |
| avatar   | varchar  | 100  | 否   | 是   | 头像URL |

Manager表

| 字段名   | 数据类型 | 长度 | 主键 | 非空 | 描述    |
| -------- | -------- | ---- | ---- | ---- | ------- |
| username | varchar  | 8    | 是   | 是   | 用户名  |
| password | varchar  | 10   | 否   | 是   | 密码    |
| avatar   | varchar  | 100  | 否   | 是   | 头像URL |

MyCollections表

| 字段名   | 数据类型 | 长度 | 主键 | 非空 | 描述     |
| -------- | -------- | ---- | ---- | ---- | -------- |
| Id       | int      | 50   | 是   | 否   | 歌曲编号 |
| songname | varchar  | 25   | 否   | 否   | 歌名     |
| singer   | varchar  | 15   | 否   | 否   | 歌手名   |

OnlinePlaylist表

| 字段名   | 数据类型 | 长度 | 主键 | 非空 | 描述     |
| -------- | -------- | ---- | ---- | ---- | -------- |
| Id       | int      | 50   | 是   | 否   | 歌曲编号 |
| songname | varchar  | 25   | 否   | 否   | 歌名     |
| singer   | varchar  | 15   | 否   | 否   | 歌手名   |

Blacklist表

| 字段名   | 数据类型 | 长度 | 主键 | 非空 | 描述     |
| -------- | -------- | ---- | ---- | ---- | -------- |
| Id       | int      | 50   | 是   | 否   | 歌曲编号 |
| songname | varchar  | 25   | 否   | 否   | 歌名     |
| singer   | varchar  | 15   | 否   | 否   | 歌手名   |

### 3. 4 系统安全和权限设置

#### 3. 4. 1 用户密码的传输和存储的保护

- 用户注册
  - 得到用户传过来的密码后，首先通过一段代码获取一个1-25之间的随机整数（偏移量）
  - 获取到随机数后，通过凯撒加密算法，对随机数与用户密码进行加密处理
  - 我们再对这个新的字符串进行哈希算法处理，得到一个新的密码，由于哈希算法的特殊性，该算法是不可逆的
  - 将加密后得到的HashCode（通过HashCode可以得到加密后的密码以及偏移量）保存到数据库中，用户注册成功

- 用户登录
  - 服务端获取到用户的id和密码后，根据用户id从数据库中获得HashCode
  - 把用户填写的用户id和密码交给服务器后台的凯撒加密算法
  - 通过用户填写的密码以及用户id进行加密得到一个新的HashCode
  - 通过这个HashCode寻找加密后的密码桶
  - 通过遍历密码桶中的标识符——用户id得到加密后的原密码以及偏移量
  - 通过得到的加密密码和偏移量进行解密得到原密码，与用户填写的密码进行比较
  - 如果处理后的结果和原密码相同，那么该用户传过来的密码是正确的，登录成功，否则，登录失败

### 3. 4. 2 常见web攻击方法及防御手段总结

#### 3. 4. 2. 1 CSRF（cross-site request forgery）跨站请求伪造

- 概念
  - 全称是跨站请求伪造(cross site request forgery),指通过伪装成受信任用户的进行访问，通俗的讲就是说我访问了A网站，然后cookie存在了浏览器，然后我又访问了一个流氓网站，不小心点了流氓网站一个链接（向A发送请求），这个时候流氓网站利用了我的身份对A进行了访问

- 被攻击的原因
  - 用户本地存储cookie，攻击者利用用户的cookie进行认证，然后伪造用户发出请求

- 预防
  - 之所以被攻击是因为攻击者利用了存储在浏览器用于用户认证的cookie，那么如果我们不用cookie来验证不就可以预防了。所以我们可以采用token（不存储于浏览器）认证，为每一个提交的表单生成一个随机token， 存储在session中，每次验证表单token，检查token是否正确
  - 通过referer识别，HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理

#### 3. 4. 2. 2 XSS（cross site script）跨站脚本攻击

- 概念
  - 全称是跨站脚本攻击（Cross Site Scripting），指攻击者在网页中嵌入恶意脚本程序。

- 被攻击的原因
  - 用户输入的数据变成了代码，比如说上面的`<script>`，应该只是字符串却有了代码的作用。

- 预防
  - 转移和过滤用户提交的信息，将输入的数据进行转义处理，比如说讲 `<` 转义成 `&lt`；

#### 3. 4. 3 session攻击，会话劫持

- 概念
  - 用某种手段得到用户session ID，从而冒充用户进行请求

- 原因
  - 由于http本身无状态，同时如果想维持一个用户不同请求之间的状态，session ID用来认证用户

- 三种方式获取用户session ID
  - 预测：PHP生成的session ID足够复杂并且难于预测，基本不可能
  - 会话劫持： URL参数传递sessionID； 隐藏域传递sessionID；比较安全的是cookie传递。但同样可以被xss攻击取得sessionID
  - 会话固定： 诱骗用户使用指定的sessionID进行登录，这样系统不会分配新的sessionID

- 防御方法
  - 每次登陆重置sessionID
  - 设置HTTPOnly，防止客户端脚本访问cookie信息，阻止xss攻击
  - 关闭透明化sessionID
  - user-agent头信息验证
  - token校验

#### 3. 4. 4 SQL注入

- 概念
  - 通过sql命令伪装成正常的http请求参数，传递到服务器端，服务器执行sql命令造成对数据库进行攻击

- 被攻击的原因
  - sql语句伪造参数，然后在对参数进行拼接的后形成破坏性的sql语句，最后导致数据库受到攻击

- 预防
  - 在java中，我们可以使用预编译语句(PreparedStatement)，这样的话即使我们使用sql语句伪造成参数，到了服务端的时候，这个伪造sql语句的参数也只是简单的字符，并不能起到攻击的作用
  - 很多orm框架已经可以对参数进行转义
  - 做最坏的打算，即使被’拖库‘('脱裤，数据库泄露')。数据库中密码不应明文存储的，可以对密码使用md5进行加密，为了加大破解成本，所以可以采用加盐的（数据库存储用户名，盐（随机字符长），md5后的密文）方式

#### 3. 4. 5 DDOS

- 概念
  - 分布式拒绝服务攻击（Distributed Denial of Service），简单说就是发送大量请求是使服务器瘫痪。DDos攻击是在DOS攻击基础上的，可以通俗理解，dos是单挑，而ddos是群殴，因为现代技术的发展，dos攻击的杀伤力降低，所以出现了DDOS，攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击

- 被攻击的原因
  - 服务器带宽不足，不能挡住攻击者的攻击流量

- 预防
  - 最直接的方法增加带宽。但是攻击者用各地的电脑进行攻击，他的带宽不会耗费很多钱，但对于服务器来说，带宽非常昂贵
  - 云服务提供商有自己的一套完整DDoS解决方案，并且能提供丰富的带宽资源
